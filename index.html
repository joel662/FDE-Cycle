<!DOCTYPE html>
<html>
  <head>
    <title>P2P AR Multiplayer - FDE CYCLE</title>
    <!-- Core AR dependencies -->
    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v6.1.1/dist/aframe-extras.min.js"></script>
    <!-- Three.js FBXLoader (uses the same Three.js version bundled in A-Frame 1.3.0 = r136) -->
    <script src="https://cdn.jsdelivr.net/npm/fflate@0.8.2/umd/index.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.136.0/examples/js/loaders/FBXLoader.js"></script>
    <!-- P2P networking -->
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>

    <script>
      // ─── Custom A-Frame component: load-fbx ───────────────────────────────
      // Usage:
      //   load-fbx="src: path/to/model.fbx; animSrc: path/to/anim.fbx; scale: 0.01"
      // animSrc is optional - if provided its animation clips are applied to the model.
      AFRAME.registerComponent('load-fbx', {
        schema: {
          src:     { type: 'string', default: '' },
          animSrc: { type: 'string', default: '' },
          scale:   { type: 'number', default: 0.01 }
        },
        init() {
          const loader = new THREE.FBXLoader();
          const s = this.data.scale;

          loader.load(this.data.src, (model) => {
            model.scale.setScalar(s);
            this.el.setObject3D('mesh', model);

            // If there are animations embedded in the model itself, play them
            if (model.animations && model.animations.length > 0 && !this.data.animSrc) {
              const mixer = new THREE.AnimationMixer(model);
              const action = mixer.clipAction(model.animations[0]);
              action.play();
              this._mixer = mixer;
            }

            // If a separate animation file is provided, load it and apply
            if (this.data.animSrc) {
              loader.load(this.data.animSrc, (animFbx) => {
                const clips = animFbx.animations;
                if (clips && clips.length > 0) {
                  const mixer = new THREE.AnimationMixer(model);
                  const action = mixer.clipAction(clips[0]);
                  action.play();
                  this._mixer = mixer;
                }
              });
            }
          }, undefined, (err) => {
            console.error('[load-fbx] Failed to load:', this.data.src, err);
          });
        },

        tick(t, dt) {
          if (this._mixer) this._mixer.update(dt / 1000);
        },

        remove() {
          this.el.removeObject3D('mesh');
        }
      });
    </script>

    <style>
      #ui-overlay {
        position: fixed;
        top: 10px;
        left: 10px;
        z-index: 999;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 15px;
        border-radius: 8px;
        font-family: sans-serif;
        display: flex;
        flex-direction: column;
        gap: 10px;
        max-width: 220px;
      }
      button {
        cursor: pointer;
        padding: 8px 12px;
        background: #4CC3D9;
        border: none;
        border-radius: 4px;
        font-weight: bold;
      }
      .status { font-size: 0.8em; color: #aaa; }
    </style>
  </head>

  <body style="margin: 0; overflow: hidden;">
    <!-- UI Controls -->
    <div id="ui-overlay">
      <div id="room-info">Initializing Room...</div>
      <button id="copy-btn" style="display:none;">Copy Invite Link</button>
      <div id="peer-status" class="status">Waiting for connection...</div>
    </div>

    <!-- AR Scene -->
    <a-scene
      embedded
      arjs="sourceType: webcam; debugUIEnabled: false; detectionMode: mono_and_matrix; matrixCodeType: 3x3;"
      cursor="rayOrigin: mouse"
      raycaster="objects: .interactable">

      <!-- ── Marker 1: FETCH (Hiro) – spinning torus knot ────────────────── -->
      <a-marker preset="hiro" id="marker-fetch">
        <a-torus-knot
          id="obj-fetch"
          class="interactable"
          radius="0.26"
          radius-tubular="0.05"
          position="0 0.5 0"
          material="color: #4CC3D9; metalness: 0.5; roughness: 0.2"
          animation="property: rotation; to: 0 360 0; loop: true; dur: 3000; easing: linear">
        </a-torus-knot>
        <a-text value="FETCH" position="0 1.2 0" align="center" color="#4CC3D9"></a-text>
      </a-marker>

      <!-- ── Marker 2: DECODE (Kanji) – Ch06 character model ─────────────── -->
      <a-marker preset="kanji" id="marker-decode">
        <a-entity
          id="obj-decode"
          class="interactable"
          load-fbx="src: model/Ch06_nonPBR (1).fbx; scale: 0.01"
          position="0 0 0"
          rotation="0 0 0">
        </a-entity>
        <a-text value="DECODE" position="0 1.5 0" align="center" color="#EF2D5E"></a-text>
      </a-marker>

      <!-- ── Marker 3: EXECUTE (Barcode 0) – Crouch→Stand animation ──────── -->
      <a-marker type="barcode" value="0" id="marker-execute">
        <a-entity
          id="obj-execute"
          class="interactable"
          load-fbx="src: model/Ch06_nonPBR (1).fbx; animSrc: animation/Crouch To Stand.fbx; scale: 0.01"
          position="0 0 0"
          rotation="0 0 0">
        </a-entity>
        <a-text value="EXECUTE" position="0 1.5 0" align="center" color="#FFC65D"></a-text>
      </a-marker>

      <a-entity camera></a-entity>
    </a-scene>

    <script>
      // ─── P2P Networking Logic (PeerJS) ───────────────────────────────────
      const urlParams = new URLSearchParams(window.location.search);
      const roomParam = urlParams.get('room');
      const peer      = new Peer();

      let conn    = null;
      let isHost  = !roomParam;

      peer.on('open', (id) => {
        if (isHost) {
          const roomUrl = `${window.location.origin}${window.location.pathname}?room=${id}`;
          document.getElementById('room-info').innerText = `Room ID: ${id.substring(0, 6)}`;
          document.getElementById('copy-btn').style.display = 'block';
          document.getElementById('copy-btn').onclick = () => {
            navigator.clipboard.writeText(roomUrl);
            alert('Invite link copied to clipboard!');
          };
        } else {
          document.getElementById('room-info').innerText = `Joining Room...`;
          connectToPeer(roomParam);
        }
      });

      peer.on('connection', (c) => {
        conn = c;
        setupConn();
        document.getElementById('peer-status').innerText = 'Connected to Peer';
      });

      function connectToPeer(remoteId) {
        conn = peer.connect(remoteId);
        conn.on('open', () => {
          setupConn();
          document.getElementById('peer-status').innerText = 'Connected to Host';
          document.getElementById('room-info').innerText  = `In Room: ${remoteId.substring(0, 6)}`;
        });
      }

      function setupConn() {
        conn.on('data', (data) => {
          if (data.type === 'interaction') {
            const el = document.getElementById(data.id);
            if (el) nudge(el);
          }
        });
        conn.on('close', () => {
          document.getElementById('peer-status').innerText = 'Waiting for connection...';
        });
      }

      function broadcast(data) {
        if (conn && conn.open) conn.send(data);
      }

      function nudge(el) {
        el.setAttribute('animation__nudge', {
          property: 'position', to: '0 0.2 0',
          dir: 'alternate', dur: 150, loop: 2
        });
      }

      // ─── Interaction: click an object to nudge it (syncs to peer) ────────
      document.querySelectorAll('.interactable').forEach(el => {
        el.addEventListener('click', () => {
          nudge(el);
          broadcast({ type: 'interaction', id: el.id });
        });
      });
    </script>
  </body>
</html>